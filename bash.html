<!DOCTYPE html>
<html>
	<title>Bash Tutorial</title>

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Bash programming tutorial">
		<meta name="keywords" content="bash, tutorial">
		<meta name="author" content="Monica Keith">	
		
		<script language="javascript">
			function showContent(num){
				var i;
				for (i=1; i<=11; i++) {
					var x = document.getElementById("content".concat(i)).style;
					if (i==num){
						x.display="block";
				  	}
					else{
						x.display="none";
				  	}
				}
			}
		</script>
	
		<style type="text/css">
			* {
			  box-sizing: border-box;
			}
			
			body {
			  font-family: Helvetica, sans-serif, Arial;
			  font-size: 14px;
			}
			
			/* Style the header */
			header {
			  background-color: #666;
			  padding: 5px;
			  text-align: center;
			  font-size: 35px;
			  color: white;
			}
			
			/* Create two columns/boxes that floats next to each other */
			nav {
			  float: left;
			  width: 30%;
			}

			nav a {
			  background-color: #eee;
			  color: black;
			  display: block;
			  padding: 12px;
			  text-decoration: none;
			}

			nav a:hover {
			  background-color: #ccc;
			}
			
			/* Style the list inside the menu */
			nav ul {
			  list-style-type: none;
			  padding: 0;
			}
			
			article {
			  float: left;
			  padding: 20px;
			  width: 70%;
			}
			
			/* Clear floats after the columns */
			section:after {
			  content: "";
			  display: table;
			  clear: both;
			}
			
			/* Style the footer */
			footer {
			  background-color: #777;
			  padding: 5px;
			  text-align: center;
			  color: white;
			}
			
			/* Responsive layout - makes the two columns/boxes stack on top of each other instead of next to each other, on small screens */
			@media (max-width: 600px) {
			  nav, article {
			    width: 100%;
			    height: auto;
			  }
			}
			
			div.hidden {
				display: none;
			}
			
			.bashcommand {
				font-family: Courier;
				font-size: 10px;
			}
			
			.example{
				text-decoration: underline;
				display: block;
			}
			
			.example:before{
				content: "Example: ";
			}
			
			table {
				border-collapse: collapse;
				font-size: 12px;
			}
			
			caption {
				padding: 5px;
				caption-side: bottom;
			}
			
			td, th {
				border: 1px solid #dddddd;
				text-align: left;
				vertical-align: top;
				padding: 5px;
			}
			
			tr:nth-child(even){
				background-color: #dddddd;
			}
			
			tr:nth-child(1){
				background-color: #b1b1b1;
			}
			
			.ghostTable td{
				border: 0px;
				background-color: #ffffff;
			}
		</style>
	</head>
	
	<body>
		<header>
		  <h2>Bash Tutorial</h2>
		</header>
		
		<section>
		  <nav>
		    <ul>
		      <li><a onclick="showContent(1);">1. Introduction to shell scripting</a></li>
		      <li><a onclick="showContent(2);">2. Creating simple bash scripts</a></li>
		      <li><a onclick="showContent(3);">3. Variables</a></li>
		      <li><a onclick="showContent(4);">4. Arithmetic calculations</a></li>
		      <li><a onclick="showContent(5);">5. Arrays</a></li>
		      <li><a onclick="showContent(6);">6. Condition-testing</a></li>
		      <li><a onclick="showContent(7);">7. Iteration</a></li>
		      <li><a onclick="showContent(8);">8. General file manipulation</a></li>
		      <li><a onclick="showContent(9);">9. Manipulating text and csv files</a></li>
		      <li><a onclick="showContent(10);">10. Manipulating image and video files</a></li>
		      <li><a onclick="showContent(11);">11. Writing more complex bash scripts</a></li>
		    </ul>
		  </nav>
		  
		  <article>
		  	<div id="content1">
			    <h2>1. Introduction to shell scripting</h2>
			    	<h3>Shell (bash) scripting, its benefits and dangers (and how to protect from them)</h3>
					
					<p>
						Shell is a program that users employ to run commands for the operating system to execute. These can be very simple 
						instructions such as coping or moving files, or long scripts that contain hundreds of commands. Users typically 
						interact with a shell using a terminal window (also referred to as command line), which can be run from the same or 
						a remote machine. There are different types of shells, but I will refer in this tutorial only to the Bourne-Again shell, 
						which is the most commonly used. The Bourne-Again shell (or simply shell, as most people call it) is installed by 
						default in any Linux or MacOS. The programming language used to write commands and scripts in shell is called bash.
					</p>
		
					<p>
						The terminal window for Mac can be found inside the applications folder and in the subfolder Utilities. You can also 
						open it by pressing the command and space bar in your keyboard to open the spotlight and then type Terminal. 
						In Linux, the easiest way to open the terminal is to use the key combination Ctl + Alt + T.
					</p>
		
					<p>
						Shell scripting is very powerful; it allows you to run any instruction on your computer or a remote machine. Things 
						that normally would take hours to do could be executed in seconds. For example, if you have thousands of files 
						inside a folder, which need to be renamed following a pattern, it would take forever to rename those files by hand. 
						However, using the command line you could do it in seconds. When you write a shell script, you know exactly what and 
						how you did things, and you will be able to replicate those commands on different files, datasets or programs.
					</p>
		
					<p>			
						However, as powerful as scripting is, it is also very dangerous. Through the terminal you will have access to any 
						files or system resources if you have the right permissions, and the freedom to do anything with them. Inadvertent 
						"small" typing errors such as adding an extra space in the remove command (<font class="bashcommand">rm</font>) could delete everything in your 
						computer (including the root directory) or any external drive connected to your machine. Similarly, the contents of 
						any file could be mistakenly removed in less than a second. What makes it harder to prevent these errors is that 
						many commands differ in name by only one letter.
					</p>
		
					<p>
						Unfortunately, there is no way to completely protect your computer from potential mistakes that you may (and you 
						will at some point) do when writing and running shell scripts. However, there are a couple of tips that you can 
						follow in order to minimize the chances of making unfixable mistakes or to prevent any mistake from becoming a 
						catastrophe:
					</p>	
		
					<ol>
						<li>
							First and most importantly, create constant backups of either your entire drive or the most important folders. 
							Preferably save those backups in an external hard drive or remote machine, which won't be constantly connected 
							to your computer. It is not a bad idea to have more than one backup if your data is not easily recoverable.
						</li><br>
		
						<li>
							If you're using a shared computer or account, control access permissions to important files and folders. You can 
							control for each file and folder who and what can be done. By managing permissions, you can allow a file to be 
							read but not to be written (hence preventing it from being modified or deleted). Or you can authorize only a 
							user or group of users for viewing, reading, writing or executing a file. In chapter 12 you will learn how to 
							manage permissions.
						</li><br>
		
						<li>
							The root user is an account in any Linux or Unix operating system (i.e. MacOS) that has access to absolutely all 
							commands, files and directories. When you login as a root in the command line, you can modify, read and write 
							protected folders and files. This is very helpful when installing software or modifying the default settings of 
							your computer. However, coding as the root user can be extremely dangerous. It is very normal to make mistakes 
							when coding and if you have all permissions, you could mistakenly delete, move or modify files that should not 
							be touched. For this reason, it is advisable to only login as a root when strictly necessary and log out once 
							you're done. More information about the root user will be covered in chapter 12.
						</li><br>
		
						<li>
							Use aliases to protect from "dangerous" commands. Two of the most commonly used but dangerous commands are 
							<font class="bashcommand">rm</font> (to remove files) and <font class="bashcommand">mv</font> (to move files). 
							The <font class="bashcommand">mv</font> command can be as harmful as the <font class="bashcommand">rm</font> 
							command because if you specify the wrong target or source paths, you can end up deleting a big number of files. 
							When you use any of these two commands, always double check what you have written before clicking enter.
						</li><br>
		
						<li>
							Be careful when copy pasting commands from a website into the terminal. There can be errors that will be 
							executed right away if the text you're copying contains a carriage return at the end of the line. It is better 
							to paste into a shell script and then either execute the shell script or copy from the shell script into the 
							command line. Although generally not dangerous, you might also run into errors when copy pasting from Microsoft 
							word or other editors that modify symbols such as dash or underscore and convert them into new symbols that 
							bash won't understand.
						</li>
		
					</ol>
		    </div>
		    
		    <div id="content2" class="hidden">
			    <h2>2. Creating simple bash scripts</h2>
			    <h3>2.1. The vi editor</h3>
				    <p>
						There are an unlimited number of editors available for writing shell scripts in Linux and Mac. A few are 
						installed by default; some are used through the terminal and some others use a graphical interface (GUI). 
						They all have pros and cons and the decision to use one or another is totally personal. In this section I will 
						explain how to use the editor vi, which is installed by default in both Linux and MacOS and can be accessed and 
						used through the terminal window. 
					</p>
					
					These are some of the advantages of vi:
					<ul>
						<li>
							It is available in all Unix systems and any type of terminal.
						</li>
						
						<li>
							It doesn't require a lot of memory to run. So, if you are running many heavy programs in your computer, 
							vi is a good option because it won't slow down the machine anymore and will still load very fast.
						</li>
						
						<li>
							Even though there are a lot of commands that you must learn to become skilled in using this program, once 
							you learn them you can use very short and fast commands to accomplish a lot of things. For example, you 
							can delete all the characters from your current cursor location to the end of the line, just by pressing two 
							times the d in your keyboard (while in command mode). Below you will find a chart with the most commonly used 
							shortcuts in vi.
						</li>
						
						<li>
							You can use it to code in different languages (i.e. it also works for Python, HTML, etc.).
						</li>
						
						<li>
							Some editors add special characters to the text and when you run scripts written in those editors, they could
							fail. vi doesn't add any special characters, and if it did, they are visible in the editor.
						</li>
						
						<li>
							If you don't like using your mouse too much, or you don't have a mouse, or your mouse doesn't work 
							properly, then vi editor is a good choice because you rarely need to use the mouse. Most things are 
							accomplished using the keyboard.
						</li>
					</ul>
					
					However, there are some disadvantages too:
					<ul>
						<li>
							The learning curve can be steep, especially for people who are new to programming and not very comfortable 
							with computers. If you're new to bash, you not only need to learn the language, but also a whole set of 
							commands specific to this program. 
						</li>
						
						<li>
							Not being able to use your mouse can end up wasting your time while you learn all the commands that are used 
							to scroll around the file or jump from one line to another.
						</li>
						
						<li>
							It doesn't give you any error messages or explanation of why it's not doing what you want. If you type the 
							wrong command, it will just do nothing (or do the wrong thing).
						</li>
					</ul>
					
					<p>
						Generally, many people with relatively good experience programming love this editor. In my opinion, it's a good 
						tool to use once you are familiar with shell and have been programming for a while. However, it might be a great 
						option for you if you like challenges or if you are already somehow familiar with shell.
					</p>
					
					<p>
						To create a new file, type (on the command line) 
						<font class="bashcommand">vi &lt;filePath&gt;/&lt;filename&gt;</font>. For example, if you want to create a file 
						called test.sh in the desktop, you should type <font class="bashcommand">vi ~/Desktop/test.sh</font>. The vi 
						editor will open in the current terminal.
					</p>
					
					<p>
						This program runs in two modes, the command mode and the typing mode. By default, it opens in command mode. 
						What this means is that anything you type is not actually being registered in the file but are commands. For 
						example, if you type <font class="bashcommand">:q!</font> as soon as you open the file, it will quit without 
						saving (because <font class="bashcommand">:q!</font> is the command for ignoring any modifications and exiting. 
						If you type <font class="bashcommand">:w</font> it will save changes to the file (or if you haven't write 
						anything, it will just create an empty file). To change to typing mode, type <font class="bashcommand">a</font> 
						(<font class="bashcommand">a</font> is the command for entering typing mode). After you type a (in lower case), 
						you can start editing your file. To go back to command mode (for example to save changes), press the key 
						<font class="bashcommand">esc</font> (top left corner of the keyboard).
					</p>
					
					<p>
						<font class="example">Using the vi editor for the first time</font>
						Open the vi editor, create a script that prints "Hello Word", and save it with the file name helloword.sh
					</p>
					
					<p>
						Step 1: Open the vi editor<br><br>
						<img src="vi_1.png"/>
					</p>
					
					<p>
						Step 2: Type <font class="bashcommand">a</font> to start editing the file. You will see that an 
						<b>--Insert--</b> message in the bottom of the terminal appears. This means that now you are in typing mode.<br><br>
						<img src="vi_2.png"/>
					</p>
					
					<p>
						Step 3: Start typing commands. The simplest command, to print a message such as 
						<font class="bashcommand">"Hello World"</font> (or any other) is <font class="bashcommand">echo</font>. The 
						syntax of this command is the word <font class="bashcommand">echo</font> followed by the message you want to 
						print out between quotation marks (in this case <font class="bashcommand">"Hello World!"</font>).<br><br>
						<img src="vi_3.png"/>
					</p>
					
					<p>
						Step 4: Once you finish your script, press the <font class="bashcommand">esc</font> key to enter command mode. 
						You will see that the <b>--Insert--</b> message at the bottom of the terminal disappears (this means that now 
						you are in command mode).<br><br>
						<img src="vi_4.png"/>
					</p>
					
					<p>
						Step 5: Save changes and exit the vi editor. In order to do this, type <font class="bashcommand">:wq</font> 
						(to write (<font class="bashcommand">w</font>) and quit (<font class="bashcommand">q</font>) at the same time). 
						The table below will show you the most commonly used commands for vi.<br><br>
						<img src="vi_5.png"/>
					</p>
					
					<p>
						Step 6: To be able to execute the script, you will have to give it running permissions. The topic of 
						permissions is a lot more complicated, so I will not go into details now (I will talk about it later). For now, 
						all you need to know is that to give running permissions to your script you have to type 
						<font class="bashcommand">chmod 775 helloword.sh</font><br><br>
						<img src="vi_6.png"/>
					</p>
					
					<p>
						The following table shows a list of vi commands that can be used in command mode and the action that will 
						happen in each case. In general, a number preceding any vi command will tell vi to repeat the command that 
						number of times. For example, <font class="bashcommand">p</font> is the command for pasting. If you write 
						(in command mode) <font class="bashcommand">2p</font>, then vi will paste whatever you copied two times where 
						the cursor is currently located.
					</p>
					
					<table>
						<caption>List of vi commands</caption>
						<tr>
							<th style="width:30%"><b>Key/command</b></th>
							<th style="width:70%"><b>Action</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">[ESC]</font></td>
							<td>Switch to command mode</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] b</font></td>
							<td>Scroll backward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] d</font></td>
							<td>Scroll down half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] f</font></td>
							<td>Scroll forward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] u</font></td>
							<td>Scroll up half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">.</font></td>
							<td>Repeat last command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">$</font></td>
							<td>Go to end of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">? string</font></td>
							<td>Search backward for <font class="bashcommand">string</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">/ string</font></td>
							<td>Search forward for string</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:0</font></td>
							<td>Go to beginning of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N</font></td>
							<td>Go to line <font class="bashcommand">N</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Md</font></td>
							<td>Delete lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MmP</font></td>
							<td>Move lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MtP</font></td>
							<td>Copy lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Mw file</font></td>
							<td>Save lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q</font></td>
							<td>Quit (does not save any changes)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q!</font></td>
							<td>Ignore any modifications made and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:%s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the entire file<br>
							The following letters can be added in the field <font class="bashcommand">option</font>:<br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the line in which the cursor is located</br>
							The following letters can be added in the field <font class="bashcommand">option</font>:</br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set ignorecase</font></td>
							<td>Ignore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set noignorecase</font></td>
							<td>Restore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set number</font></td>
							<td>Turn on line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set nonumber</font></td>
							<td>Turn off line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax on</font></td>
							<td>Turn on syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax off</font></td>
							<td>Turn off syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w</font></td>
							<td>Save changes</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w file</font></td>
							<td>Save changes to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:wq</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:x</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">a</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">A</font></td>
							<td>Switch to editing mode and continue writing at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">i</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">I</font></td>
							<td>Switch to editing mode and continue writing at the beginning of the line where the cursor is
							located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">cw</font></td>
							<td>Delete the rest of the word in which the cursor is located (keeps the characters located before the 
							cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">D</font></td>
							<td>Delete the rest of the line in which the cursor is located (keeps the characters and words located 
							before the cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dd</font></td>
							<td>Delete the entire line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dw</font></td>
							<td>Delete the whole word in which the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">J</font></td>
							<td>Put the next line at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">o</font></td>
							<td>Open line below cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">O</font></td>
							<td>Open line above cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">p</font></td>
							<td>Paste below current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">P</font></td>
							<td>Paste above current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:u</font></td>
							<td>Undo previous command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:U</font></td>
							<td>Undo all changes to line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">x</font></td>
							<td>Delete text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">X</font></td>
							<td>Delete (backspace) text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">yy</font></td>
							<td>Copy line in which the cursor is located</td>
						</tr>
					</table>
				
				<h3>2.2. Other editors</h3>	
					<p>
						As I previously mentioned, there is an unlimited number of editors and the choice of which to use is totally 
						personal. The following editors are available for both Linux and MacOS: vim, emacs, gedit (which is also 
						installed by default in Linux and uses a GUI, great for beginners), and Eclipse (among many others). Eclipse 
						is a lot more than an editor; it is a development environment used for programming in many other languages 
						(mainly Java) and for software development and modeling. The following are editors available only for MacOS: 
						Xcode, TextWrangler, TextMate, Notepad++, and Atom (among many others).
					</p>
					
				<h3>2.3. Tips for writing scripts</h3>
					<ol>
						<li>
						Albeit not mandatory, the first line of any bash script should be the shebang 
						(<font class="bashcommand">#!/bin/bash</font>). This line indicates that the script is written in bash 
						(instead of tcsh, for example) and that the bash interpreter should execute it.<br><br>
						</li>
						
						<li>
						Be organized when writing scripts. As you start writing longer and more complicated programs, this 
						will become more important. Try to comment as often as possible so that other people can understand what 
						your script is doing, which parameters are needed and what they mean or to understand the output. 
						Commenting will also help you fix errors or keep track of the version, changes, authorship, etc, or to 
						remember what your script does if you don't use it for a while. To insert a comment, you simply start the 
						line with a hash (<font class="bashcommand">#</font>). Any line that starts with this symbol will not be 
						executed (except for the shebang). Also try to use indentation to know where pieces of code start and end 
						(for example when doing loops). If you don't indentate, understanding your own code will be very 
						difficult. Part of being organized is also using appropriate variable names. Use names that are associated 
						to the structure you're using (for example, if you're creating an array, naming it 
						<font class="bashcommand">array</font> will help you remember that this variable is an array and not a 
						string or a number) and try to use short names (for example, instead of naming a variable 
						<font class="bashcommand">myListOfSubjects</font>, you can call it 
						<font class="bashcommand">subjList</font>).</br><br>
						</li>
						
						<li>
						It is also a good idea to use the following commands at the beginning of any script:</br>
						<font class="bashcommand">set -e</font>: This will make the program exit as soon as it encounters an error. 
						If you don't use this, then even if there's an error your code will continue to execute.<br> 
						<font class="bashcommand">set -u</font>: This will make the program exit when using undeclared variables. 
						It will prevent the program from executing the wrong commands if you misspell a variable name.<br><br>
						</li>
						
						<li>
						Use double quotes (<font class="bashcommand">"</font>) when declaring a string, single quotes 
						(<font class="bashcommand">'</font>) when declaring a character, and no quotes when declaring numbers. 
						This will prevent word splitting (when declaring a string that has spaces) and other errors in your 
						code.<br><br>
						</li>
						
						<li>
						Use functions. This topic will be covered in chapter X. Using functions will make your code more readable, 
						reusable, and will allow you to run only parts of the code without having to comment all the lines. This 
						is especially useful when debugging or re-running a script.<br><br>
						</li>
						
						<li>
						If you are declaring a variable that the value should never change, then use the word 
						<font class="bashcommand">readonly</font> before the variable name.<br> 
						For example, if I want to declare a variable called <font class="bashcommand">age</font> with value 
						<font class="bashcommand">30</font> and this value should never be replaced, then you should declare it 
						like this:<br>
						<font class="bashcommand">readonly age=30</font><br>
						Instead of:<br>
						<font class="bashcommand">age=30</font><br><br>
						
						If at some point in the script you try to replace the value of that variable, you will get an error message:
						<br>
						<font class="bashcommand">readonly age=30</font><br>
						<font class="bashcommand">age=29</font><br>
						<font class="bashcommand">-bash: age: readonly variable</font>
						</li>
					</ol>
				
				<h2>2.4. Running a script</h2>
					<p>
						Running a shell script is easy. You only type the path and name of the file in the command line and then press 
						enter. For example, if your script is located in the Desktop and is called helloWord.sh, then to execute it 
						you should type the following in the command line:<br>
						<font class="bashcommand">~/Desktop/helloWord.sh</font><br><br>
						If you get a Permission Denied error, this means that you must change its permissions to make it runnable. 
						The topic of permissions is a bit complicated and will be explained in detail in chapter 12. But for now, you 
						only need to know that the following command will allow you to execute the script if it's not runnable:<br>
						<font class="bashcommand">chmod 775 &lt;script_path_and_name&gt;</font>
					</p>
		    </div>
		    
		    <div id="content3" class="hidden">
		    	<h2>3. Variables</h2>
		    	<h3>3.1. Utility, declaration and accessing variables</h3>
		    		<p>
						A very important aspect of programming (in bash or any other language) is the ability to use a label (called 
						variable) to indicate some other quantity (a number, character, string or command). For example, I can use 
						the variable <font class="bashcommand">${desktop}</font> to represent the string 
						<font class="bashcommand">"/Users/monica/Desktop"</font>. Or the variable 
						<font class="bashcommand">${year}</font> to represent the number <font class="bashcommand">2020</font> 
						(after correctly declaring these variables). Variables can be used for many purposes, including making the 
						code more readable, short and organized and to prevent typing errors. They are also very useful in cases in 
						which the actual value of a variable is not known before executing the program, or when you need to save the 
						output of one command to use as input for another command. For example, when reading the contents of a file 
						you can read line by line in an iterative manner (which you will learn later), saving each line in a variable 
						and then doing something with it (depending the purpose of the program). 
					</p>
					
					<p>
						The easy thing about declaring variables in bash is that you don't have to specify data types. However, if 
						the value that you are assigning is a string of characters, you should use quotation marks 
						(<font class="bashcommand">"</font>) between the beginning and the end of your string (especially if the 
						string contains spaces). You must also be careful to not include any white space between the variable name, 
						the equals sign, and the value. Additionally, be aware that the quotation marks used in bash are 
						<font class="bashcommand">"</font>, which is different than those used in Microsoft Word. They look very 
						similar, but bash won't recognize the later ones. So, if you copy-paste from Microsoft Word a command that
						includes quotation marks, you will probably get an error.
					</p>
					
					<p>
						<font class="example">Declaring variables of different data types</font>
						In the following commands, I will assign a number to the variable <font class="bashcommand">YEAR</font>, a String 
						to the variables <font class="bashcommand">MONTH</font> and <font class="bashcommand">NAME</font> and a character to 
						the variable <font class="bashcommand">GENDER</font>. As you can observe, numbers, strings and characters should 
						be declared in a different manner.
					</p>
					
					<p>
						<font class="bashcommand">
						$ YEAR=2018<br>
						$ MONTH="August"<br>
						$ NAME="Monica Keith"<br>
						$ GENDER='F'
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when declaring variables</font>
						The following commands will produce errors because there is a white space before and/or after the equal sign 
						(<font class="bashcommand">=</font>), or because the quotation marks (<font class="bashcommand">"</font>) are 
						missing when declaring a string that contains a space. Bellow each erroneous command you can see the error 
						that Bash produces.
					</p>
					
					<p>
						<font class="bashcommand">
						$ NAME ="Monica Keith"<br>
						-bash: NAME: command not found<br>
						$ NAME= "Monica Keith"<br>
						-bash: Monica Keith: command not found<br>
						$ NAME = "Monica Keith"<br>
						-bash: NAME: command not found<br>
						$ NAME=Monica Keith<br>
						-bash: Keith: command not found
						</font>
					</p>
					
					<p>
						Once you assign a value to a variable, you can reference it with a dollar sign, located immediately before 
						the variable name. You can also reference a variable by including curly brackets 
						(<font class="bashcommand">{}</font>) at the beginning and the end of the variable name. It is better (but 
						not mandatory) to always reference variables using brackets. This will prevent errors in your code (specially 
						when referencing strings that have spaces or special characters).
					</p>
					
					<p>
						<font class="example">Referencing variables</font>
						In the following example, I will declare variable <font class="bashcommand">VAR1</font> with value 
						<font class="bashcommand">2</font>, and variable <font class="bashcommand">VAR2</font> with value 
						<font class="bashcommand">"Subject"</font>. Then, I will use the function 
						<font class="bashcommand">echo</font> to print in the command line the value of the two variables.
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1=2<br>
						$ VAR2="Subject"<br>
						$ echo ${VAR1}<br>
						2<br>
						$ echo ${VAR2}<br>
						Subject
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when referencing variables</font>
						When referencing a variable, be careful not to include any space before or after the brackets. The following 
						examples will produce an error because of the inclusion of a space around the brackets:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${ VAR2}<br>
						-bash: ${ VAR2}: bad substitution<br>
						$ echo ${VAR2 }<br>
						-bash: ${VAR2 }: bad substitution<br>
						$ echo ${ VAR2 }<br>
						-bash: ${ VAR2 }: bad substitution
						</font>
					</p>
					
					<p>
						The following erroneous reference (with a space between the dollar sign and the first bracket) will not cause 
						an error but will not substitute <font class="bashcommand">${VAR2}</font> for the correct value. It will just 
						print <font class="bashcommand">$ {VAR2}</font> instead of <font class="bashcommand">Subject</font>.
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo $ {VAR2}<br>
						$ {VAR2}
						</font>
					</p>
					
					<p>
						<font class="example">Concatenating variables</font>
						You can concatenate different variables and characters to form new strings. To do this, you will need to 
						reference the variables using the curly brackets and use quotation marks at the beginning and the end of your 
						final string. For example, if you want to use the previously declared variables 
						<font class="bashcommand">VAR1</font> and <font class="bashcommand">VAR2</font> to generate the String 
						<font class="bashcommand">Subject_02</font>, you can concatenate them the following way:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${VAR2}<br>
						Subject<br>
						$ echo ${VAR1}<br>
						2<br>
						$ echo "${VAR2}_0${VAR1}"<br>
						Subject_02
						</font>
					</p>
					
					<p>Here are a few more examples on how to declare and concatenate variables:</p>
					
					<p>
						<font class="bashcommand">
						$ ID="Subject_202"<br>
						$ VOLUME=20<br>
						$ MEASURE="mm"<br>
						$ echo "${ID}: ${VOLUME}${MEASURE}"<br>
						Subject_202: 20mm
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1="MacOS"<br>
						$ VAR2="Linux"<br>
						$ VAR3="Windows"<br>
						$ echo "(${VAR1},${VAR2},${VAR3})"<br>
						(MacOS,Linux,Windows)
						</font>
					</p>
					
					<p>
						<font class="example">A common mistake when concatenating variables</font>
						It is very common when you are referencing many variables or concatenating variables to create a long string 
						to forget the closing quotation mark. For example, writing<br>
						<font class="bashcommand">echo "(${VAR1},${VAR2},${VAR3})</font><br>
						instead of<br>
						<font class="bashcommand">echo "(${VAR1},${VAR2},${VAR3})"</font>
					</p>
					
					<p>
						When that happens and you click enter in the keyboard, the command line won't allow you to enter any more 
						commands. You will see the symbol <font class="bashcommand">></font> and if you continue pressing enter it 
						will do nothing. This is because the command line is waiting for you to close the open String. To close the 
						string just add the missing quotation mark or cancel and ignore what you have written so far in the current 
						line by pressing CTR+C. 
					</p>
					
				<h3>3.2. Rules for assigning variable names</h3>
					<p>You can assign any value to a variable. However, a variable cannot have just any name. There are a few 
					rules for assigning variable names.</p>
					
					<ol>
						<li>
							A variable name should not be a number.<br>
							This type of variable is only used to read arguments on a shell script. For example, 
							<font class="bashcommand">$1</font> refers to the first argument of a script, 
							<font class="bashcommand">$2</font> to the second argument, etc. Later you will learn the meaning and use 
							of script arguments.
						</li><br>
						
						<li>
							Variable names must start with an alphabetical letter or an underscore.<br>
							Variable names can contain any number, but it should not be located at the beginning.
						</li><br>
						
						<li>
							Do not use <font class="bashcommand">$</font> or <font class="bashcommand">${}</font> to declare a 
							variable. These characters are used only to reference variables (not to declare).
						</li><br>
						
						<li>
							Do <u>NOT</u> assign the name <font class="bashcommand">PATH</font> to any variable.<br>
							If you do so, you won't get any error right away. But it will mess up the execution of other programs. 
							<font class="bashcommand">PATH</font> is a system variable that specifies a set of directories where 
							executable programs are located. For example, when you install a software that runs in the command line 
							(i.e. FSL), the path to the executable of that program will be included in the system variable 
							<font class="bashcommand">PATH</font>. So, if you rename that variable, you won't be able to execute the 
							program again in the current terminal. If you forget about this rule and mistakenly re-write the value 
							of this variable, close the current terminal and open a new one. Every time you open a new terminal, 
							this system variable will be re-set to the correct value (which is stored in the bash_profile, we will 
							talk about this file in a later chapter). At any moment you can know the value of your 
							<font class="bashcommand">PATH</font> by typing <font class="bashcommand">echo ${PATH}</font>. You will 
							see something like this (although this will significantly varies between one computer and the other 
							depending which programs you have installed and referenced in the bash_profile):<br><br>
							
							<font class="bashcommand">
							$ echo ${PATH}<br>
							/usr/local/fsl/bin:/Applications/freesurfer/bin:/Applications/freesurfer/fsfast/bin:/Applications/freesurfer/tktools:/usr/local/fsl/bin:/Applications/freesurfer/mni/bin:/Users/bunbury/bin:/Applications/MATLAB_R2018a.app/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
							</font><br><br>
							
							Another Unix reserved name that you should not use is <font class="bashcommand">BASH</font>. There is a long list 
							of Unix reserved words that I will not include here but you will learn as you get more experienced.
						</li><br>
						
						<li>
							Avoid using the following reserved characters from appearing in variable names:
							<font class="bashcommand">/ &gt; &lt; | : &amp; . *</font>	
						</li><br><br>
						
						<font class="example">Some valid and invalid variable names</font><br>
						<table>
							<caption>Valid and invalid variable names</caption>
							<tr>
								<th style="width:50%"><b>Valid variable names</b></th>
								<th style="width:50%"><b>Invalid variable names</b></th>
							</tr>
							<tr>
								<td>V</td>
								<td>1</td>
							</tr>
							<tr>
								<td>VAR</td>
								<td>1VAR</td>
							</tr>
							<tr>
								<td>VAR1</td>
								<td>2_VAR</td>
							</tr>
							<tr>
								<td>VAR_1</td>
								<td>.VAR</td>
							</tr>
							<tr>
								<td>_VAR1</td>
								<td>$VAR</td>
							</tr>
							<tr>
								<td>_1VAR</td>
								<td>${VAR}</td>
							</tr>
							<tr>
								<td>VARIABLE_NAME</td>
								<td>{VAR}</td>
							</tr>
							<tr>
								<td>PATH1</td>
								<td>PATH</td>
							</tr>
							<tr>
								<td>BASH1</td>
								<td>BASH</td>
							</tr>
						</table>
						
						<p>
							Variable names can be in lower and/or upper case. However, they are case sensitive. If you declare a 
							variable as <font class="bashcommand">VAR1</font>, but you reference it as 
							<font class="bashcommand">${var1}</font>, bash will not recognize the value. You must reference it as 
							<font class="bashcommand">${VAR1}</font>.
						</p>
					</ol>
					
				<h3>3.3. Reading user input into a variable</h3>
					<p>
						The command <font class="bashcommand">read</font> is the counterpart of <font class="bashcommand">echo</font>. 
						Instead of printing things in the terminal the way <font class="bashcommand">echo</font> does, 
						<font class="bashcommand">read</font> reads input from the user and saves it in the specified variable (in 
						this case <font class="bashcommand">VAR</font>). The word read is followed by the name of the variable where 
						you want to save the information. In the following example, I am going to read the input from the user and 
						save it in the variable <font class="bashcommand">VAR</font>. Generally, Bash will read everything that is 
						written until the user presses the Enter key and save all the information in the corresponding variable.
					</p>
					
					<p>
						<font class="example">Saving user input into a new variable</font>
						<font class="bashcommand">
						$ echo "Username:"<br>
						Username:<br>
						$ read VAR<br>
						Noemi<br>
						$ echo "You typed: ${VAR}"<br>
						You typed: Noemi
						</font>
					</p>
					
					<p>
						There are some flags (options) that can be added to the command read to change the way in which information is 
						displayed or captured:
					</p>
					
					<table>
						<caption>Options for reading user input</caption>
						<tr>
							<th style="width:30%"><b>Flag</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>
							Silent mode. The characters that the user inputs are not displayed (used specially when asking the user to 
							input a password).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p "MESSAGE"</font></td>
							<td>
							Displays the <font class="bashcommand">MESSAGE</font> where the user must write the input.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-n NUM_CHARS</font></td>
							<td>
							The input line ends after reading <font class="bashcommand">NUM_CHARS</font> characters, rather than waiting for the 
							user to press Enter in the keyboard.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-d 'CHAR_NEW_LINE'</font></td>
							<td>
							<font class="bashcommand">CHAR_NEW_LINE</font> is used to determine the end of the input line (if different than Enter).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>
							Backslash does not act as an escape character but instead is part of the line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t NSECONDS</font></td>
							<td>
							Bash will stop reading the user input after <font class="bashcommand">NSECONDS</font>. Whatever was entered in that 
							time is captured as the input line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a ARRAY_NAME</font></td>
							<td>
							The words that the user inputs are assigned to sequential indices of the array 
							<font class="bashcommand">ARRAY_NAME</font>. The array is emptied before assigning the values if it 
							already exists.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u FILEDESCRIPTOR</font></td>
							<td>
							Read input from <font class="bashcommand">FILEDESCRIPTOR</font>.
							</td>
						</tr>
					</table>
					
					<p>
						The following examples will show how to use the flags mentioned in the previous table. Be aware on how the 
						variable name is always written at the end of the command. In this section, I will not explain the use of 
						flags <font class="bashcommand">-a</font> and <font class="bashcommand">-u</font> because we haven't learned 
						yet about arrays or file manipulation. Some of the examples will also show common mistakes that will make bash 
						show an error.
					</p>
					
					<p>
						<font class="example">read -s</font>
						In the following example, the flag <font class="bashcommand">-s</font> causes the user input to be silenced, 
						so when the user writes the password, it is not shown in the screen. If the user input is 
						<font class="bashcommand">ThisIsMyPassword</font>, then that string is saved in the variable 
						<font class="bashcommand">PASSWORD</font>. While the user is writing its password and until it presses Enter, 
						you will see the following symbol underneath <font class="bashcommand">$ read -s PASSWORD </font>:
						<img src="pwd.png"/>. Afterwards, the symbol will disappear.
					</p>
					
					<p>
						In the example of a wrong syntax, the mistake is that the variable <font class="bashcommand">PASSWORD</font> 
						is written before the flag <font class="bashcommand">-s</font>. The variable must go at the end of the command 
						independently of which flags are used. As a result, bash is not silencing the user input, is giving the invalid 
						identifier error, and is not saving any string in the variable.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -s PASSWORD<br>
								<img src="pwd.png"/><br>
								$ echo ${PASSWORD}</br>
								ThisIsMyPassword
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read PASSWORD -s<br>
								ThisIsMyPassword<br>
								-bash: read: `-s': not a valid identifier
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -p</font>
						The flag <font class="bashcommand">-p</font> is useful if you want to prompt a message so that the user 
						knows what the input should be. The examples in the following table combine the flags 
						<font class="bashcommand">-p</font> and <font class="bashcommand">-s</font> to indicate the user to input a 
						password and hide the password while its being typed. The prompt message should go right after the flag 
						<font class="bashcommand">-p</font>.
					</p>
					
					<p>
						The following table shows some examples of commands written using a wrong syntax (as well as the correct way 
						to write them). In the first example, the error is that the prompt message is not located right after the flag 
						<font class="bashcommand">-p</font> (instead, it is located after the flag <font class="bashcommand">-s</font>). 
						In the second example, the error is that the variable <font class="bashcommand">PASSWORD</font> is not located 
						at the end of the command. In the third example, the problem is that the prompt message 
						(<font class="bashcommand">Please input your password</font>) is not surrounded by quotation marks. So, for 
						bash only the first word of that sentence (<font class="bashcommand">Please</font>) is the prompt message, and 
						the next word (<font class="bashcommand">input</font>) is read as the variable name. The rest of the command 
						(<font class="bashcommand">your password</font>) is ignored. That is why when reading 
						<font class="bashcommand">${PASSWORD}</font>, nothing is echoed, the variable is empty because nothing was 
						saved with that variable name. Instead, the input was saved in <font class="bashcommand">${input}</font>. This 
						is the reason why the prompt message should always be surrounded by quotation marks.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -p "Please input your password" -s PASSWORD<br>
								Please input your password <img src="pwd.png"/><br>
								$ echo ${PASSWORD}<br> 
								ThisIsMyPassword
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read -p -s "Please input your password" PASSWORD<br>
								-s<br>
								-bash: read: `Please input your password': not a valid identifier
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -p "Please input your password" -s PASSWORD<br>
								Please input your password <img src="pwd.png"/><br>
								$ echo ${PASSWORD}<br> 
								ThisIsMyPassword
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read PASSWORD -s -p "Please input your password"<br>
								ThisIsMyPassword<br>
								-bash: read: `-s': not a valid identifier
								</font>
							</td>
						</tr>
						<tr>
							<td>
							</td>
							<td>
								<font class="bashcommand">
								read -s -p Please input your password ThisIsMyPassword<br>
								$ echo $PASSWORD<br>
								<br>
								$ echo ${input}<br>
								ThisIsMyPassword
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -n</font>
						In the following example, <font class="bashcommand">-n 1</font> forces bash to accept only one character in the 
						input. So, the terminal will finish reading after one character. Here we are combining flags 
						<font class="bashcommand">-n</font> and <font class="bashcommand">-p</font> to also prompt a message to the 
						user.
					</p>
					
					<p>
						In the wrong syntax, <font class="bashcommand">1</font> (the number of characters to be accepted) and the 
						prompt message are located in the wrong place. The number of characters accepted should always go after 
						<font class="bashcommand">-n</font> and the prompt message should always go after 
						<font class="bashcommand">-p</font>. 
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -n 1 -p "Do you wish to continue? (y/n)" VAR<br>
								Do you wish to continue? (y/n)y<br>
								$ echo $VAR<br>
								y
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read -n -p 1 "Do you wish to continue? (y/n)" VAR<br>
								-bash: read: -p: invalid number
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -p "Do you wish to continue? (y/n)" -n 1 VAR<br>
								Do you wish to continue? (y/n)y<br>
								$ echo $VAR<br>
								y					
								</font>
							</td>
							<td>
								<font class="bashcommand">
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -d</font>
						In the following example the end of the line is determined by the character <font class="bashcommand">#</font> 
						instead of Enter (using the flag <font class="bashcommand">-d</font>). As soon as the user types 
						<font class="bashcommand">#</font>, bash finishes reading and saves the input in the variable 
						<font class="bashcommand">VAR</font>.
					</p>
					
					<p>
						In the wrong syntax, the command is missing the apostrophes (<font class="bashcommand">'</font>) around the 
						character <font class="bashcommand">#</font>.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -d '#' VAR<br>
								$ echo $VAR<br>
								SomeText
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read -d # VAR<br>
								-bash: read: -d: option requires an argument<br>
								read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">The backslash</font>
						In bash, certain characters have special meanings. For example, the dollar sign 
						(<font class="bashcommand">$</font>) is used to reference a variable. When you type 
						<font class="bashcommand">${VAR}</font>, it will print the value of 
						<font class="bashcommand">VAR</font> instead of the actual string 
						"<font class="bashcommand">${VAR}</font>". The backslash (<font class="bashcommand">\</font>) is used to remove 
						those special meanings from the character followed by it. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR="Some text"<br>
						$ echo ${VAR}<br>
						Some text<br>
						$ echo \${VAR}<br>
						${VAR}
						</font>
					</p>
					
					<p>
						When using the flag <font class="bashcommand">-r</font>, the backslash is part of the line instead of being 
						used as an escape character. The following table shows examples in which the user inputs the same string but it 
						is read differently because in one case the flag is used (first column) but not in the other (second column).
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Examples using flag -r</b></th>
							<th style="width:50%"><b>Examples without the flag -r</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -r VAR<br>
								C:\Documents\Newsletters\Summer2018.pdf<br>
								$ echo ${VAR}<br>
								C:\Documents\Newsletters\Summer2018.pdf
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read VAR<br>
								C:\Documents\Newsletters\Summer2018.pdf<br>
								$ echo ${VAR}<br>
								C:DocumentsNewslettersSummer2018.pdf
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -r MESSAGE<br>
								In HTML \n is used to indicate a new line<br>
								$ echo ${MESSAGE}<br>
								In HTML \n is used to indicate a new line
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read MESSAGE<br>
								In HTML \n is used to indicate a new line<br>
								$ echo ${MESSAGE}<br>
								In HTML n is used to indicate a new line
								</font>
							</td>
						</tr>
					</table>
				
				<h3>3.4. Using &lt;&lt;&lt; to get input from a different source</h3>
					<p>
						So far, we have used the command <font class="bashcommand">read</font> to save the user input into a variable. 
						This command can also be used to read from other sources (i.e. other variables or files).
					</p>
					
					<p>
						<font class="example">Reading content from a variable</font>
						In the following example, <font class="bashcommand">read</font> reads the content of the variable 
						<font class="bashcommand">VAR</font>, but only keeps the first character (because it is using the 
						<font class="bashcommand">-n 1</font> flag):
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR=yes<br>
						$ read -n 1 R &lt;&lt;&lt; ${VAR}<br>
						$ echo ${R}<br>
						y
						</font>
					</p>
					
					<p>
						<font class="example">Reading and saving the output of a function</font>	
						<font class="bashcommand">read</font> also allows you to read the output of a function and save it in a variable. 
						In this example, we are saving the output of the <font class="bashcommand">pwd</font> function into the variable 
						<font class="bashcommand">CURRENT_DIR</font>. <font class="bashcommand">pwd</font> is a function that prints the 
						current folder in which you are located in the command line. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						/Users/myUserName<br>
						$ read CURRENT_DIR &lt;&lt;&lt; $(pwd)<br>
						$ echo ${CURRENT_DIR}<br>
						/Users/myUserName
						</font>
					</p>
					
					<p>
						<font class="example">**Example specific for people doing neuroimaging**</font>
						<b>WARNING:</b> If you have never analyzed MRI brain images, the following paragraph might sound like written in 
						extraterrestrial language, and it probably will not work in your computer since you need neuroimaging software
						to execute it.
					</p>
					
					<p>	
						In this example, we are reading the output of a function and saving it in the variable 
						<font class="bashcommand">VOL</font>. The output of this function (<font class="bashcommand">fslstats -V</font>) 
						consists of two values separated by a space. The first value is the volume of a region of interest (ROI) from 
						an MRI file in number of voxels, and the second value is the volume in mm<sup>3</sup>. Because we are using the 
						flag <font class="bashcommand">-d ' '</font>, it will read only until the first space (which is the character 
						we are choosing to indicate the end of line). So, bash will save in the variable 
						<font class="bashcommand">VOL</font> only the volume in number of voxels and not in mm<sup>3</sup>. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V<br>
						196 186.920166<br>
						$ read -d ' ' VOL &lt;&lt;&lt; $(fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V)<br>
						$ echo $VOL<br>
						196
						</font>
					</p>					
		    </div>
		    
		    <div id="content4" class="hidden">
		    	<h2>4. Arithmetic calculations</h2>
		    	<h3>4.1. Integer calculations</h3>
			    	<p>In order to compute arithmetic calculations with integers you can use one of the following syntaxes:</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">$(( OPERATION ))</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer numbers. Including addition (<font class="bashcommand">+</font>), subtraction 
								(<font class="bashcommand">-</font>), multiplication (<font class="bashcommand">*</font>), division 
								(<font class="bashcommand">&#247;</font>), square root (<font class="bashcommand">sqrt(NUM)</font>), 
								exponentiation (<font class="bashcommand">NUM**EXP</font>), etc.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((++NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression that 
								contains <font class="bashcommand">++NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM++))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM++</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((--NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression 
								that contains <font class="bashcommand">--NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM--))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM--</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR+=NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR + $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR-=NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR - $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">(( $i % 2 ))</font>
							</td>
							<td>
								<font class="bashcommand">true</font> if <font class="bashcommand">i</font> is an odd number, 
								<font class="bashcommand">false</font> if <font class="bashcommand">i</font> is even.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of $(( OPERATION ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Example</b></th>
						<th style="width:70%"><b>Explanation</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ echo $(( 2 + 1 ))<br>
								3
							</font>
						</td>
						<td>2 + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ A=2<br>
							$ echo $(( ${A} + 1 ))<br>
							3
							</font>
						</td>
						<td>A + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} + ${B} ))<br>
								3
							</font>
						</td>
						<td>A + B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( ${A} - ${B} ))<br>
							1
							</font>
						</td>
						<td>A - B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} * ${B} ))<br>
								2
							</font>
						</td>
						<td>A x B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} / ${B} ))<br>
								2
							</font>
						</td>
						<td>A &#247; B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( $(( ${A} + ${B} )) * $(( ${A} - ${B} )) ))<br>
								3
							</font>
						</td>
						<td>(A + B) x (A - B)</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${B} / ${A} ))<br>
								0
							</font>
						</td>
						<td>
							B &#247; A<br>
							The result is zero because this syntax is used for integer numbers. So, if the result of the operation 
							is not an integer, it will be rounded to the nearest integer. In the following section you will learn 
							how to operate with non-integer numbers. 
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ echo $(( ${A} ** 3 ))<br>
								8
							</font>
						</td>
						<td>A<sup>3</sup></td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ A=2<br>
							$ B=4<br>
							$ echo $(( ${A} ** ${B} ))<br>
							16
							</font>
						</td>
						<td>A<sup>B</sup></td>
					</tr>
					</table>
					
					<p>
					<font class="example">Usage of ((++NUM)) and ((NUM++))</font>
					In order to increment the value of a variable by one, there are a couple of options. Some of these options will be 
					very useful when doing iterations (which you will learn later on).
					</p>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $(( ${NUM} + 1 ))<br>
							2<br>
							$ echo ${NUM}<br>
							1<br><br>
							</font>
								
							The command echo <font class="bashcommand">$(( ${NUM} + 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> plus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is 
							echoed at the end, it still has value 1 (instead of 2).
						</td>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $((++NUM))<br>
							2<br>
							$ echo ${NUM}<br>
							2<br><br>
							</font>
							
							The command <font class="bashcommand">echo $((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
							NUM=$(( ${NUM} + 1 ))<br>
							echo ${NUM}<br><br>
							</font>
							
							First, increases the value of variable <font class="bashcommand">NUM</font> in one, and then it echoes 
							the result. Opposite to the example in the left, here the variable value is actually modified. And 
							opposite to the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">echo</font>).
						</td>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $((NUM++))<br>
							1<br>
							$ echo ${NUM}<br>
							2<br><br>
							</font>
							
							The command echo <font class="bashcommand">$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
							echo ${NUM}<br>
							NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First echoes the value of <font class="bashcommand">NUM</font>. Then, it increases the value of the 
							variable. 
						</td>		
					</tr>
					</table><br>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ A=$(( ${NUM} + 1 ))<br>
							$ echo ${A}<br>
							2<br>
							$ echo ${NUM}<br
							1<br><br>
							</font>
							
							The command <font class="bashcommand">A=$(( ${NUM} + 1 ))</font> assigns to 
							<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> plus one, but it 
							does not modify the value of <font class="bashcommand">NUM</font>.
						</td>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ A=$((++NUM))<br>
							$ echo ${A}<br>
							2<br>
							$ echo ${NUM}<br>
							2<br><br>
							</font>
							
							The command <font class="bashcommand">A=$((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
							NUM=$(( ${NUM} + 1 ))<br>
							A=${NUM}<br><br>
							</font>
							
							First increases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
							the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
							(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 2.
						</td>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ A=$((NUM++))<br>
							$ echo ${A}<br>
							1<br>
							$ echo ${NUM}<br>
							2<br><br>
							</font>
							
							The command <font class="bashcommand">A=$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
							A=${NUM}<br>
							NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First assigns the value of <font class="bashcommand">NUM</font> to the new variable <font class="bashcommand">A</font>. 
							After that, it increases the value of <font class="bashcommand">NUM</font>. So, if the initial value of 
							<font class="bashcommand">NUM</font> was 1, after the operation <font class="bashcommand">A</font> will equal 1 and 
							<font class="bashcommand">NUM</font> will equal 2.
						</td>
					</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((--NUM)) and ((NUM--))</font>
						Expressions <font class="bashcommand">((--NUM))</font> and <font class="bashcommand">((NUM--))</font> work in 
						a very similar way than the previous ones, but instead of increasing the value of
						 <font class="bashcommand">NUM</font> by one, they decrease the value of <font class="bashcommand">NUM</font> 
						 by one. These expressions will also be very useful once you learn iteration. 
					</p>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $(( ${NUM} - 1 ))<br>
							0<br>
							$ echo ${NUM}<br>
							1<br><br>		
							</font>
		
							The command echo <font class="bashcommand">$(( ${NUM} - 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> minus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is echoed 
							at the end, it still has value 1 (instead of 0).
							</td>
							<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $((--NUM))<br>
							0<br>
							$ echo ${NUM}<br>
							0<br><br>
							</font>
		
							The command echo <font class="bashcommand">$((--NUM))</font> is equivalent to this sequence of instructions:
		
							<font class="bashcommand">
							NUM=$(( ${NUM} - 1 ))<br>
							echo ${NUM}<br><br>
							</font>
		
							First, decreases the value of variable <font class="bashcommand">$NUM</font> in one, and then it echoes the 
							result. Opposite to the example in the left, here the variable value is actually modified. And opposite to 
							the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">=</font>).
							</td>
							<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $((NUM--))<br>
							1<br>
							$ echo ${NUM}<br>
							0<br><br>
							</font>
		
							The command echo <font class="bashcommand">$((NUM--))</font> is equivalent to this sequence of 
							instructions:<br><br>
		
							<font class="bashcommand">
							echo ${NUM}<br>
							NUM=$(( ${NUM} - 1 ))<br><br>
							</font>
		
							First, echoes the value of <font class="bashcommand">NUM</font>. Then, it decreases the value of the 
							variable. 
							</td>
						</tr>
					</table><br>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$(( ${NUM} - 1 ))<br>
									$ echo ${A}<br>
									0<br>
									$ echo ${NUM}<br>
									1<br><br>
								</font>
								
								The command <font class="bashcommand">A=$(( ${NUM} - 1 ))</font> assigns to 
								<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> minus one, but it 
								does not modify the value of <font class="bashcommand">NUM</font>.
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((--NUM))<br>
									$ echo ${A}<br>
									0<br>
									$ echo ${NUM}<br>
									0<br><br>
								</font>
								
								The command <font class="bashcommand">A=$((--NUM))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									NUM=$(( ${NUM} - 1 ))<br>
									A=${NUM}<br><br>
								</font>			
								
								First, decreases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
								the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
								(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 0.			
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((NUM--))<br>
									$ echo ${A}<br>
									1<br>
									$ echo ${NUM}<br>
									0<br><br>
								</font>
								
								The command <font class="bashcommand">A=$((NUM--))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									A=${NUM}<br>
									NUM=$(( ${NUM} - 1 ))<br><br>
								</font>
								
								First, assigns the value of <font class="bashcommand">NUM</font> to the new variable 
								<font class="bashcommand">A</font>. After that, it increases the value of 
								<font class="bashcommand">NUM</font>. So, if the initial value of <font class="bashcommand">NUM</font> was 
								1, after the operation <font class="bashcommand">A</font> will equal 1 and 
								<font class="bashcommand">NUM</font> will equal 2.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((VAR+=NUM))</font>
						This expression is a compact way of writing <font class="bashcommand">VAR=$(( ${VAR} + ${NUM} ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Compact expression</b></th>
						<th style="width:70%"><b>Extended equivalent</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ ((A+=2))<br>
								$ echo ${A}<br>
								3<br><br>
							</font>				
						</td>
						<td>
							<font class="bashcommand">((A+=2))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">A=$(( ${A} + 2 ))</font>
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=$((A+=2))<br>
								$ echo ${A}<br>
								3<br>
								$ echo ${B}<br>
								3<br>
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=2))</font> is equivalent to this sequence of instructions:<br><br>
		
							<font class="bashcommand">
								A=$(( ${A} + 2 ))<br>
								B=${A}
							</font>
						</td>
					</tr>		
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ ((A+=B))<br>
								$ echo ${A}<br>
								10<br>
								$ echo ${B}<br>
								9
							</font>					
						</td>
						<td>
							<font class="bashcommand">((A+=B))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">A=$(( ${A} + ${B} ))</font><br><br>
		
							The value of <font class="bashcommand">B</font> is not being modified.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ B=$((A+=B))<br>
								$ echo ${A}<br>
								10<br>
								$ echo ${B}<br>
								10
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=B))</font> is equivalent to this sequence of instructions:<br><br>
	
							<font class="bashcommand">
								A=$(( ${A} + ${B} ))<br>
								B=${A}<br><br>
							</font>
	
							In this case, the value of <font class="bashcommand">B</font> is being modified because the result of 
							<font class="bashcommand">((A+=B))</font> is being assigned to it (opposite to the previous example).
						</td>
					</tr>	
					</table>
					
					<p>
						<font class="example">Usage of ((VAR-=NUM))</font>
						This expression is a compact way of writing: <font class="bashcommand">VAR=$(( ${VAR} - ${NUM} ))</font>
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Compact expression</b></th>
							<th style="width:70%"><b>Extended equivalent</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ ((A-=2))<br>
									$ echo ${A}<br>
									-1
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=2))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">A=$(( ${A} - 2 ))</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=$((A-=2))<br>
									$ echo ${A}<br>
									-1<br>
									$ echo ${B}<br>
									-1
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=2))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									A=$(( ${A} - 2 ))<br>
									B=${A}	
								</font>				
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ ((A-=B))<br>
									$ echo ${A}<br>
									-8<br>
									$ echo ${B}<br>
									9
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=B))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">A=$(( ${A} - ${B} ))</font><br><br>
								
								The value of <font class="bashcommand">B</font> is not being modified.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ B=$((A-=B))<br>
									$ echo ${A}<br>
									-8<br>
									$ echo ${B}<br>
									-8
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=B))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									A=$(( ${A} - ${B} ))<br>
									B=${A}<br><br>
								</font>
								
								In this case, the value of B is being modified because the result of 
								<font class="bashcommand">((A-=B))</font> is being assigned to it (opposite to the previous 
								example).
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of (( $i % 2 ))</font>
						<font class="bashcommand">
							$for i in $(seq 10)<br>
							>do<br>
							>if (( $i % 2 ))<br>
							>then<br>
							>echo $i is odd<br>
							>else<br>
							>echo $i is even<br>
							>fi<br>
							>done<br>
							1 is odd<br>
							2 is even<br>
							3 is odd<br>
							4 is even<br>
							5 is odd<br>
							6 is even<br>
							7 is odd<br>
							8 is even<br>
							9 is odd<br>
							10 is even
						</font>
					</p>
					
				<h3>4.2. Non-integer calculations</h3>
					<p>
						When programming in bash, you will often need to do mathematical operations that involve non-integer 
						calculations. To do this, you will need the <font class="bashcommand">bc</font> utility. You can use this 
						utility also for integer calculations, but it is normally left for advanced math.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer or non-integer numbers. Including addition (<font class="bashcommand">+</font>), 
								subtraction (<font class="bashcommand">-</font>), multiplication 
								(<font class="bashcommand">*</font>), division (<font class="bashcommand">/</font>), square root 
								(<font class="bashcommand">sqrt(NUM)</font>), exponentiation 
								(<font class="bashcommand">NUM**EXP</font>), etc. It will round the result to the closest 
								integer.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc -l</font>
							</td>
							<td>
								Flag <font class="bashcommand">-l</font> will not round the result. Instead, will print it with 
								all the decimals.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
							</td>
							<td>
								Will only print <font class="bashcommand">NDECIMALS</font> instead of all the decimals.
							</td>
						</tr>
					</table><br>
					
					<font class="example">echo "OPERATION" | bc</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc<br>
							1<br>
							$ echo "2 / 3" | bc<br>
							0
						</font>
					</p>
					
					<font class="example">echo "OPERATION" | bc -l</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc -l<br>
							1.23482849604221635883<br>
							$ echo "2 / 3" | bc -l<br>
							.66666666666666666666
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=$(echo "2.34 / 1.895" | bc)<br>
							$ B=$(echo "2.34 / 1.895" | bc -l)<br>
							$ echo ${A}<br>
							1<br>
							$ echo ${B}<br>
							1.23482849604221635883<br>
							$ echo "${A} + ${B}" | bc -l<br>
							2.23482849604221635883<br>
							$ echo "${A} + ${B}"<br>
							1 + 1.23482849604221635883
						</font>
					</p>
					
					<p>
						Look at the difference between the last two expressions. They are almost the same except for the 
						<font class="bashcommand">| bc -l</font> at the end of the first expression. Yet, the results are very 
						different. That is because in the second case we are just printing the text 
						<font class="bashcommand">"${A} + ${B}"</font>, while in the first one we are evaluating the expression 
						written in that text, with the use of the <font class="bashcommand">bc</font> utility. The following 
						example may clarify this concept:
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "${A} + ${B}=$(echo "${A} + ${B}" | bc -l)"<br>
							1 + 1.23482849604221635883=2.23482849604221635883
						</font>
					</p>
					
					<p>
						To find the square root of a number you use the expression <font class="bashcommand">sqrt()</font>, like 
						in many other programming languages.
					</p>
					
					<font class="example">finding the square root of 10 and saving it in variable A</font>
					<p>
						<font class="bashcommand">
							$ A=$(echo "sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							3.16227766016837933199
						</font>
					</p>
					
					<p>
						Knowing this, you can do any type of operations with non-integer numbers. Just by writing the desired 
						expression between the quotation marks, or combine integer and non-integer calculations. Let’s look at 
						a few more examples:
					</p>
					
					<font class="bashcommand">
						<p>
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							4.39710615621059569082<br>
							$ echo $((2**3))<br>
							12.397106156210595690828<br>
							$ echo "(2.34 / 1.895) + sqrt (10) + $((2**3))" | bc -l<br>
							12.39710615621059569082<br>
							$ echo "(2.34 / 1.895) + sqrt (10) + 2^3" | bc -l<br>
							12.39710615621059569082<br>
							$ echo "2 + 2" | bc -l<br>
							4<br>
							$ echo "2 + 2"<br>
							2 + 2<br>
							$ echo "2 + 2= $(echo "2 + 2" | bc -l)"<br>
							2 + 2= 4
						</p>	
							
						<p>
							$ A=$(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							4.39710615621059569082<br>
							$ echo $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							4.39710615621059569082<br>
							$ echo "(2.34 / 1.895) + sqrt (10)= $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)"<br>
							(2.34 / 1.895) + sqrt (10)= 4.39710615621059569082				
						</p>
					</font>
					
					<font class="example">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
					<p>
						Clearly, some of the results of the previous examples have way too many decimals. You can cut the number 
						of decimals using scale.
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							4.39710615621059569082<br>
							$ echo "scale=3; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							4.396<br>
							$ echo "scale=0; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							4
						</font>
					</p>
					
					<font class="example">Comparing non-integers</font>
					<p>
						In order to compare non-integers you can use the <font class="bashcommand">awk</font> function. This 
						function will be studied more in detail in later chapters as it is mainly used for processing files and 
						strings. But as this example shows, it can also be used to deal with numbers.
					</p>
		    </div>
		    
		    <div id="content5" class="hidden">
		    	<h2>5. Arrays</h2>
		    	<h3>5.1. Declaring and assigning values</h3>
			    	<p>
						An array is a data structure that stores a group of elements and allows you to access each element 
						individually or all elements sequentially. For example, you can have an array of subject IDs. The first 
						object in the array would be the ID of your first subject; the second object would be the ID of your 
						second subject, and so on. An analogy could be a To Do List. In that case, you would have an array of 
						things to do and you can ask yourself what is the first thing in your To-Do list, the second thing, or 
						the last thing, etc. There are different ways of creating an array, as well as different ways of adding 
						elements to it:
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY[INDEX]=VAL</font>
							</td>
							<td>
								If <font class="bashcommand">ARRAY</font> hasn't been initialized, it will create the array and 
								put element <font class="bashcommand">VAL</font> in the position 
								<font class="bashcommand">INDEX</font>. The first element of an array is always in 
								<font class="bashcommand">INDEX=0</font>, instead of <font class="bashcommand">INDEX=1</font>. 
								If <font class="bashcommand">ARRAY</font> already exists, it will replace 
								<font class="bashcommand">ARRAY</font> in the position <font class="bashcommand">INDEX</font> by 
								the value <font class="bashcommand">VAL</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
							</td>
							<td>
								Initializes <font class="bashcommand">ARRAY</font> and puts the values inside the parenthesis 
								into the array, respecting the same order. You can specify any number of values. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">read -a ARRAY</font>
							</td>
							<td>
								The words that the user inputs are assigned to sequential indices of 
								<font class="bashcommand">ARRAY</font>. The words must be separated by spaces. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY</font>
							</td>
							<td>
								Splits the user input using delimiter <font class="bashcommand">DEL</font>, which must be a 
								character or a space. Then, saves the different elements into 
								<font class="bashcommand">ARRAY</font>. The array is emptied before assigning the values if it 
								already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
							</td>
							<td>
								Splits <font class="bashcommand">STRING</font> using delimiter 
								<font class="bashcommand">DEL</font>, which must be a character or a space. Then, saves the 
								different elements into <font class="bashcommand">ARRAY</font>. The array is emptied before 
								assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=($(seq FIRST STEP SIZE))</font>
							</td>
							<td>
								Creates an array of equally spaced numbers beginning with <font class="bashcommand">FIRST</font> 
								and separated by <font class="bashcommand">STEP</font>. It will add 
								<font class="bashcommand">SIZE</font> numbers to <font class="bashcommand">ARRAY</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(count -digits N FIRST LAST)</font>
							</td>
							<td>
								Creates an array of numbers, each with <font class="bashcommand">N</font> number of digits, 
								starting with <font class="bashcommand">FIRST</font> and ending with 
								<font class="bashcommand">LAST</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(seq N)</font>
							</td>
							<td>
								Creates an array of sequential numbers, starting with 1 and ending with 
								<font class="bashcommand">N</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=(ELEMENT1 ELEMENT3 ...)</font>
							</td>
							<td>
								Creates an array with the elements specified inside the parenthesis.
							</td>
						</tr>
					</table>
					
					<p>
						In the following examples we will use the syntax <font class="bashcommand">${ARRAY[INDEX]}</font> to 
						access the element located in the position <font class="bashcommand">INDEX</font> inside 
						<font class="bashcommand">ARRAY</font>. Remember that the first item in an array has index 0, the second 
						item has index 1, etc. I will also use the syntax <font class="bashcommand">${#ARRAY[@]}</font> to get 
						the number of non-empty values inside <font class="bashcommand">ARRAY</font>.
					</p>
					
					<font class="example">ARRAY[INDEX]=VAL</font>
					<p>
						Create an array of subjects' age where each element in the array corresponds to the age of one subject. 
						There are five subjects, so the size of the array is five. Remember, subject 1 will have its age in the 
						position 0, subject 2 in the position 1, etc. This is because <u>in bash, arrays start in the position 0 
						instead of position 1</u>. After assigning all the values to my array, I can print its contents using 
						the expression echo <font class="bashcommand">${ARRAY[@]}</font>. I can also check the size of my array 
						using <font class="bashcommand">echo ${#ARRAY[@]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[0]=59<br>
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							59 63 21 15 94<br>
							$ echo "Array size: ${#age[@]}"<br>
							Array size: 5
						</font>
					</p>
					
					<p>
						In the following example, I will start assigning values to the array in the position 1 (instead of 0). 
						That is not a problem, but the first position of my array (index=0) will remain empty, and my array will 
						have only 4 values. If I echo the item in position 0 (echo <font class="bashcommand">${ARRAY[0]}</font>), 
						I will get an empty string.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							63 21 15 94<br>
							$ echo "Array size: ${#age[@]}"<br>
							Array size: 4<br>
							$ echo "age(0): ${age[0]} "<br>
							age(0):
						</font>
					</p>
					
					<p>
						<font class="example">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
						It is also possible to initiate an array and assign all the values at the same time. To print an element 
						of the array, located in the position <font class="bashcommand">INDEX</font>, you must use the expression 
						<font class="bashcommand">${ARRAY[INDEX]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Germany' 'Spain' 'Canada')<br>
							$ echo "The element in position 0 is: ${array[0]}"<br>
							The element in position 0 is: Colombia<br>
							$ echo "The element in position 1 is: ${array[1]}"<br>
							The element in position 1 is: United States<br>
							$ echo "The element in position 2 is: ${array[2]}"<br>
							The element in position 2 is: Germany<br>
							$ echo "The element in position 3 is: ${array[3]}"<br>
							The element in position 3 is: Spain<br>
							$ echo "The element in position 4 is: ${array[4]}"<br>
							The element in position 4 is: Canada<br>
							$ echo "List of elements in the array: ${array[@]}"<br> 
							List of elements in the array: Colombia United States Germany Spain Canada<br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							The number of elements in the array is 5
						</font>
					</p>
					
					<p>
						After you declare an array, it doesn't need to stay static. You can keep adding items:
					</p>
					
					<p>
						<font class="bashcommand">
							$ array[5]="Argentina"<br>
							$ array[6]="France"<br>
							$ echo "List of elements in the array: ${array4[@]}"<br>
							List of elements in the array: Colombia United States Germany Spain Canada Argentina France
						</font>
					</p>
					
					<p>
						<font class="example">read -a ARRAY</font>
						Another way of creating and initializing an array is by reading a user input. As we previously learned, 
						the command read captures the user input and saves it in a variable. By using the flag 
						<font class="bashcommand">-a</font>, the user can input more than one word (separated by a space) and bash 
						will assign each word to sequential indexes of the array, starting at 0.
					</p>
					
					<p>
						<font class="bashcommand">
							$ read -a ARRAY<br>
							Element1 Element2 Element3<br>
							$ echo ${ARRAY[0]}<br>
							Element1<br>
							$ echo ${ARRAY[1]}<br>
							Element2<br>
							$ echo ${ARRAY[2]}<br>
							Element3
						</font>
					</p>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY</font>
						If you want to use a different delimiter other than a space to split the user input into array elements, 
						you can add <font class="bashcommand">IFS='DEL'</font> before the read command, with 
						<font class="bashcommand">DEL</font> being any character.
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY<br>
							Element1/Element2/Element3<br>
							$ echo ${ARRAY[0]}<br>
							Element1<br>
							$ echo ${ARRAY[1]}<br>
							Element2<br>
							$ echo ${ARRAY[2]}<br>
							Element3
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY<br>
							1.2.3<br>
							$ echo ${ARRAY[0]}<br>
							1<br>
							$ echo ${ARRAY[1]}<br>
							2<br>
							$ echo ${ARRAY[2]}<br>
							3
						</p>
					</font>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
						The same way as you can split a user input into elements of an array using a specific delimiter, you can 
						split elements of a string. This is very useful when trying to retain parts of a file path.
					</p>
					
					<p>
						<font class="bashcommand">
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							Element1<br>
							$ echo ${ARRAY[1]}<br>
							Element2<br>
							$ echo ${ARRAY[2]}<br>
							Element3
						</font>
					</p>
					
					<p>
						In the following example, the input string (<font class="bashcommand">/Element1/Element2/Element3</font>) 
						starts with the delimiter (<font class="bashcommand">/</font>). So, when you split it, 
						<font class="bashcommand">Element1</font> will be in position 1 (not in position 0), because the element 
						in position 0 would be the string located before the first appearance of the delimiter (which is an 
						empty string). 
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "/Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<br>
							$ echo ${ARRAY[1]}<br>
							Element1<br>
							$ echo ${ARRAY[2]}<br>
							Element2<br>
							$ echo ${ARRAY[3]}<br>
							Element3
						</p>
						
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "./Folder/Subfolder/file.txt"<br>
							$ echo ${ARRAY[0]}<br>
							.<br>
							$ echo ${ARRAY[1]}<br>
							Folder<br>
							$ echo ${ARRAY[2]}<br>
							Subfolder<br>
							$ echo ${ARRAY[3]}<br>
							file.txt
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "1.2.3"<br>
							1.2.3<br>
							$ echo ${ARRAY[0]}<br>
							1<br>
							$ echo ${ARRAY[1]}<br>
							2<br>
							$ echo ${ARRAY[2]}<br>
							3
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "23.485"<br>
							$ echo "The integer part is ${ARRAY[0]}, and the decimal part is 0.${ARRAY[1]}"<br>
							The integer part is 23, and the decimal part is 0.485
						</p>
					</font>
					
					<p>
						<font class="example">ARRAY=($(seq FIRST STEP SIZE))</font>
						You can also create an array of equally spaced or consecutive numbers in a very easy way using the 
						command <font class="bashcommand">seq</font>. In this example, I will create an array of numbers that go 
						from 15 to 19. The distance between each number (<font class="bashcommand">STEP</font>) is 0.5.
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 0.5 19))<br>
							$ echo ${ARRAY[0]}<br>
							15<br>
							$ echo ${ARRAY[1]}<br>
							15.5<br>
							$ echo ${ARRAY[2]}<br>
							16<br>
							$ echo ${ARRAY[3]}<br>
							16.5<br>
							$ echo ${ARRAY[4]}<br>
							17<br>
							$ echo ${ARRAY[5]}<br>
							17.5<br>
							$ echo ${ARRAY[6]}<br>
							18<br>
							$ echo ${ARRAY[7]}<br>
							18.5<br>
							$ echo ${ARRAY[8]}<br>
							19
						</font>
					</p>
					
					<p>
						In this example, I will create an array of numbers that go from 1 to 10. The distance between each 
						number (<font class="bashcommand">STEP</font>) is 2. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 1 2 10))<br>
							$ echo ${ARRAY[0]}<br>
							1<br>
							$ echo ${ARRAY[1]}<br>
							3<br>
							$ echo ${ARRAY[2]}<br>
							5<br>
							$ echo ${ARRAY[3]}<br>
							7<br>
							$ echo ${ARRAY[4]}<br>
							9
						</font>
					</p>
					
					<p>
						When the step between the numbers is 1, it doesn't need to be written:<br>
	 					<font class="bashcommand">($(seq 15 1 19))</font> is the same as 
	 					<font class="bashcommand">($(seq 15 19))</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 19))<br>
							$ echo ${ARRAY[0]}<br>
							15<br>
							$ echo ${ARRAY[1]}<br>
							16<br>
							$ echo ${ARRAY[2]}<br>
							17<br>
							$ echo ${ARRAY[3]}<br>
							18<br>
							$ echo ${ARRAY[4]}<br>
							19
						</font>
					</p>
					
					<font class="example">ARRAY=(ELEMENT1 ELEMENT2 ELEMENT3 ...)</font>
					
					<p>
						<font class="bashcommand">
							$ array=(e1 e2 e3 e4 e5 e6)<br>
							$ echo ${array[0]}<br>
							e1<br>
							$ echo ${array[1]}<br>
							e2<br>
							$ echo ${array[2]}<br>
							e3<br>
							$ echo ${array[3]}<br>
							e4<br>
							$ echo ${array[4]}<br>
							e5<br>
							$ echo ${array[5]}<br>
							e6
						</font>
					</p>
					
					<p>
						Bash and other programs have functions that return a list of elements. For example, as you will learn in 
						the section of file manipulation, the command <font class="bashcommand">ls</font> returns the list of 
						files in your current working directory. In these cases, instead of manually entering a list of elements 
						between parentheses to convert into an array, you can write the function name, and its output will be saved in the array:
					</p>
					
					<font class="bashcommand">
						<p>
							$ ls<br>
							<table class="ghostTable">
								<tr>
									<td>@update.afni.binaries</td>
									<td>Downloads</td>
									<td>abin</td>
								</tr>
								
								<tr>
									<td>AFNI_data5</td>
									<td>Library</td>
									<td>afni_handouts</td>
								</tr>
								
								<tr>
									<td>AFNI_data6</td>
									<td>Movies</td>
									<td>dax</td>
								</tr>
								
								<tr>
									<td>AFNI_demos</td>
									<td>Music</td>
									<td>std_meshes</td>
								</tr>
								
								<tr>
									<td>Desktop</td>
									<td>Pictures</td>
									<td>suma_demo</td>
								</tr>
								
								<tr>
									<td>Documents</td>
									<td>Public</td>
									<td>test.txt</td>
								</tr>
							</table>
						</p>
						
						<p>
							$ array=($(ls))<br>
							$ echo ${array[0]}<br>
							@update.afni.binaries<br>
							$ echo ${array[1]}<br>
							AFNI_data5<br>
							$ echo ${array[2]}<br>
							AFNI_data6<br>
							$ echo ${array[3]}<br>
							AFNI_demos<br>
							$ echo ${array[4]}<br>
							Desktop
						</p>
					</font>
					
				<h3>5.2. Array operations</h3>
					<p>Once you have initialized an array, you can do the following operations with it:</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Syntax</b></th>
						<th style="width:70%"><b>Usage</b></th>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the element in position <font class="bashcommand">INDEX</font> inside 
							<font class="bashcommand">ARRAY</font>. The first index is 0, then 1, etc.<br>
							See the examples section of creating sub-strings 
							(<font class="bashcommand">${STRING:START:NUM}</font>) to know how to obtain a character in a 
							specific position inside a string instead of an array.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[@]}</font><br>
							or<br>
							<font class="bashcommand">${#STRING}</font>
						</td>
						<td>
							Returns the size of <font class="bashcommand">ARRAY</font> (number of non-empty elements) or the 
							number of characters in <font class="bashcommand">STRING</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the size of the element located in the position <font class="bashcommand">INDEX</font> 
							(number of characters).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]}</font>
						</td>
						<td>
							Returns all the elements of <font class="bashcommand">ARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font>. You could use the symbols 
							<font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace 
							all elements that follow a specific pattern (<a href="#ex5">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces the <b>first occurrence</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font> (a string 
							is an array of characters). You could use the symbols <font class="bashcommand">*</font>, 
							<font class="bashcommand">#</font> and <font class="bashcommand">%</font> inside 
							<font class="bashcommand">OLD_ITEM</font> to replace all elements that follow a specific pattern 
							(<a href="#ex6">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING//OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font>. You could use 
							the symbols <font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace all 
							elements that follow a specific pattern (<a href="#ex7">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY[@]}")</font>
						</td>
						<td>
							Copy the elements of <font class="bashcommand">ARRAY</font> into 
							<font class="bashcommand">NEWARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY1[@]}" "${ARRAY2[@]}" "${ARRAY3[@]}" ...)</font>
						</td>
						<td>
							Concatenates arrays <font class="bashcommand">ARRAY1</font>, 
							<font class="bashcommand">ARRAY2</font>, and <font class="bashcommand">ARRAY3</font> into one 
							single array called <font class="bashcommand">NEWARRAY</font>. You can concatenate as many 
							arrays as you want.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">unset ARRAY</font>
						</td>
						<td>
							Deletes <font class="bashcommand">ARRAY</font> from memory.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]:START:NUM}</font><br>
							or<br>
							<font class="bashcommand">${STRING:START:NUM}</font>
						</td>
						<td>
							Creates a sub-array from <font class="bashcommand">ARRAY</font> (or a sub-string from 
							<font class="bashcommand">STRING</font>). Beginning with the element in the position 
							<font class="bashcommand">START</font> and containing <font class="bashcommand">NUM</font> 
							number of elements.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))</font>
						</td>
						<td>
							Sorts in alphabetical order array and saves the result in sorted.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' sum=$(echo "scale=1;${array[*]}"|bc)</font>
						</td>
						<td>
							Adds all elements in array and saves the result in variable <font class="bashcommand">sum</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' avg=$(echo "scale=1;(${array[*]})/${#array[@]}"|bc)</font>
						</td>
						<td>
							Calculates the average of elements in <font class="bashcommand">array</font> and saves the 
							result in variable <font class="bashcommand">avg</font>.
						</td>
					</tr>
				</table>
				
				<div id="ex1">
					<p><font class="example">${ARRAY[INDEX]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element of the array in position 0 is: ${array[0]}"<br>
							The element of the array in position 0 is: Colombia<br>
							$ echo "The element of the array in position 1 is: ${array[1]}"<br>
							The element of the array in position 1 is: United States
						</font>
					</p>
				</div>
				
				<div id="ex2">
					<p><font class="example">${#ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							The number of elements in the array is 4
						</font>
					</p>
				</div>
				
				<div id="ex3">
					<p>
						<font class="example">${#ARRAY[INDEX]}</font>
						<font class="bashcommand">${#ARRAY[INDEX]}</font> will return the number of characters of the element of 
						the array located in the specified index. <font class="bashcommand">Colombia</font> is in index 0, 
						<font class="bashcommand">United States</font> in index 1, <font class="bashcommand">Spain</font> in 
						index 2. <font class="bashcommand">Spain</font> has six characters, so 
						<font class="bashcommand">${#ARRAY[2]}=6</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element in position 2 is ${array[2]}, and its size is ${#array[2]}"<br>
							The element in position 2 is Spain, and its size is 5
						</font>
					</p>
				</div>
				
				<div id="ex4">
					<p><font class="example">${ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo ${array[@]}<br>
							Colombia United States Spain Canada
						</font>
					</p>
				</div>
				
				<div id="ex5">
					<p>
						<font class="example">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						Substitute all the instances of <font class="bashcommand">Colombia</font> 
						(<font class="bashcommand">OLD_ITEM</font>) by Spain (<font class="bashcommand">NEW_ITEM</font>) in 
						the array.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Colombia' 'Canada')<br>
							$ echo ${array[@]/Colombia/Spain}<br>
							Spain United States Spain Canada
						</font>
					</p>
					
					<p>To remove an item, you simply substitute it by nothing (leave <font class="bashcommand">NEW_ITEM</font> 
					empty).</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Subject01' 'Subject01' 'Subject03' 'Subject04')<br>
							$ echo ${array[@]/Subject01/}<br>
							Subject03 Subject04
						</font>
					</p>
				</div>
				
				<div id="ex6">
					<p>
						<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						A string is an array of characters. So, you can replace parts of a string the same way that you do 
						with an array (without the <font class="bashcommand">[@]</font>).
					</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Neuro/Research}<br>
							/Users/Research/Desktop
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Desktop/}<br>
							/Users/Neuro/
						</p>
					</font>
					
					<p>
						You can use patterns to remove a group of elements from an array. For example, in the following 
						array you have three items that start by <font class="bashcommand">AA</font>, so you use as 
						<font class="bashcommand">ITEM_TO_REPLACE: AA*</font>. As you can see, the three items that start 
						with <font class="bashcommand">AA</font> are deleted.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('AA123' 'AB345' 'AA987' 'BB098' 'AA456')<br>
							$ echo ${ARRAY[@]/AA*/}<br>
							AB345 BB098
						</font>
					</p>
					
					<p>
						Below are a few more examples on how to use patterns to remove a group of items from an array:
					</p>
					
					<p>
						Delete all items that end with the letter Z (<font class="bashcommand">'HGTZ'</font> and 
						<font class="bashcommand">'ZZZZ'</font>):<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('QWER' 'HGTZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/*Z/}<br>
							QWER QRJD JHGF
						</font>
					</p>
					
					<p>
						Delete all items that have an <font class="bashcommand">A</font> at the beginning and a 
						<font class="bashcommand">Z</font> at the end (<font class="bashcommand">'ASDFZ'</font>). Observe 
						that either <font class="bashcommand">'RFGHJZ'</font> nor <font class="bashcommand">'ZZZZ'</font> get 
						deleted because even though they end with a <font class="bashcommand">Z</font>, they don't start 
						with an <font class="bashcommand">A</font>, so those two strings don't follow the 
						<font class="bashcommand">A*Z</font> pattern: <br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/A*Z/}<br>
							RFGHJZ QRJD ZZZZ JHGF
						</font>
					</p>
					
					<p>
						To replace the front-end occurrences of a substring within an array, you can use the following 
						syntax: <font class="bashcommand">${ARRAY[@]/#SUBSTRING_TO_REPLACE/NEW_SUBSTRING}:</font><br>
						<font class="bashcommand">
							$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')<br>
							$ echo ${ARRAY[@]/#SUBJ/SUBJECT}<br>
							SUBJECT0 SUBJECT9 SUBJECT3 SUBJECT4 SUBJECT3
						</font>
					</p>
					
					<p>
						To replace the back end occurrences of a substring within an array, use the symbol 
						<font class="bashcommand">%</font> instead of <font class="bashcommand">#</font> and the same syntax 
						as before:<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ID_001' 'AGE_001' 'GENDER_001' 'QC_001')<br>
							$ echo ${ARRAY[@]/%001/125}<br>
							ID_125 AGE_125 GENDER_125 QC_125
						</font> 
					</p>
				</div>
				
				<div id="ex7">
					<p>
						<font class="example">${STRING//OLD_ITEM/NEW_ITEM}</font>
						With strings, contrary to how it happens with arrays, using the previous syntax will only replace the 
						first occurrence of <font class="bashcommand">OLD_ITEM</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P/Neuro/Research}<br>
							/Users/Research/Desktop/Neuro
						</font>
					</p>
					
					<p>In order to replace all occurrences of <font class="bashcommand">OLD_ITEM</font> you must use double 
					slash:</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P//Neuro/Research}<br>
							/Users/Research/Desktop/Research
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P//e/}<br>
							/Usrs/Nuro/Dsktop
						</p>
					</font>
				</div>
				
				<div id="ex8">
					<p>
						<font class="example">NEWARRAY=("${ARRAY[@]}")</font>
						This syntax is used to copy all the elements of one array into a new one.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ NEWARRAY=("${ARRAY[@]}")<br>
							$ echo ${NEWARRAY[@]}<br>
							ASDFZ RFGHJZ QRJD ZZZZ JHGF
						</font>
					</p>
				</div>
				
				<div id="ex9">
					<p>
						<font class="example">NEWARRAY=("${ ARRAY1[@]}" "${ARRAY2[@]}" "${ ARRAY3[@]}" ...)</font>
						Concatenating arrays is very similar to copying arrays. If you want to concatenate array 
						<font class="bashcommand">A</font> and <font class="bashcommand">B</font>, and save the result in 
						<font class="bashcommand">C</font>. You just copy <font class="bashcommand">A</font> after 
						<font class="bashcommand">B</font> (using the previous syntax) and assign it to 
						<font class="bashcommand">C</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ declare -a B=('3333' '2222' '1111')<br>
							$ C=("${A[@]}" "${B[@]}")<br>
							$ echo ${C[@]}<br>
							ASDFZ RFGHJZ QRJD ZZZZ JHGF 3333 2222 1111
						</font>
					</p>
				</div>
				
				<div id="ex10">
					<p>
						<font class="example">unset ARRAY</font>
						If your script creates very big temporary arrays that won't be used again, you might want to delete them 
						to free some memory. For that you use the command unset. You might want to use unset also if you want to 
						make sure that the array is empty before you start adding elements.
					</p>
					
					<p>
						In this example, after deleting array A and echoing it again, nothing will be printed as the array is now 
						empty:
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${A[@]}<br>
							ASDFZ RFGHJZ QRJD ZZZZ JHGF<br>
							$ unset A<br>
							$ echo ${A[@]}
						</font>
					</p>
				</div>
				
				<div id="ex11">
					<p>
						<font class="example">${ARRAY[@]:START:NUM}</font>
						By using <font class="bashcommand">${ARRAY[@]:START:N}</font>, you can create a sub-array that 
						contains <font class="bashcommand">N</font> elements from the original array, starting from the 
						index <font class="bashcommand">START</font>. Remember, the index of the first item is 0. So, in the 
						following example the index of <font class="bashcommand">'Element1'</font> is 0 and the index of 
						<font class="bashcommand">'Element2'</font> is 1.
					</p>
					
					<p>
						Extract 2 items from <font class="bashcommand">ARRAY</font> starting in index 0 (items 
						<font class="bashcommand">'Element1'</font> and <font class="bashcommand">'Element2'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:0:2}<br>
							Element1 Element2
						</font>
					</p>
					
					<p>
						Extract 3 items from <font class="bashcommand">ARRAY</font> starting in index 2 (items 
						<font class="bashcommand">'Element3'</font>, <font class="bashcommand">'Element4'</font> and 
						<font class="bashcommand">'Element5'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:3}<br>
							Element3 Element4 Element5
						</font>
					</p>
					
					<p>
						Extract 4 items from <font class="bashcommand">ARRAY</font> starting in index 2. There are only 
						three elements from the item in index 2 until the end of the array. So, bash will only extract 3 
						items (there's no 4th item to extract).
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:4}<br>
							Element3 Element4 Element5
						</font>
					</p>
				</div>
				
				<div id="ex12">
					<p>
						<font class="example">${STRING:START:NUM}</font>
						Extract characters from a string. Remember, a string is also an array (an array of characters).
					</p>
					
					<p>
						<font class="bashcommand">
							$ S="Colombia"<br>
							$ echo "The first character in ${S} is ${S:0:1}"<br>
							The first character in Colombia is C<br>
							$ echo "The third character in ${S} is ${S:2:1}"<br>
							The third character in Colombia is l<br>
							$ SIZE=${#S}<br>
							$ echo $SIZE<br>
							8<br>
							$ echo "The last two characters in ${S} are ${S:$(( ${SIZE} - 2 )):2}"<br>
							The last two characters in Colombia are ia
						</font>
					</p>
				</div>
				
				<div id="ex13">
					<p>
						<font class="example">IFS=$'\n' sorted=($(sort <<<"${array[*]}"))</font>
						Sort <font class="bashcommand">array</font> and save the output in sorted (array stays the same):
					</p>
					
					<p>
						<font class="bashcommand">
							$ array=(ewrwr dfgfgdf asda yrtytr)<br>
							$ echo ${array[@]}<br>
							ewrwr dfgfgdf asda yrtytr<br>
							$ IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))<br>
							${sorted[@]}<br>
							asda dfgfgdf ewrwr yrtytr<br>
							$ echo ${array[@]}<br>
							ewrwr dfgfgdf asda yrtytr
						</font>
					</p>
				</div>
		    </div>
		    
		    <div id="content6" class="hidden">
		    	<h2>6. Condition-testing</h2>
		    
		    	<p>
					Variables can be used to test if a certain condition is true or false, and therefore be able to take a 
					different course of action depending on the result of the test. For example, you might want to evaluate 
					if a file exists to decide if you can copy it into a different folder or not. For condition-testing you 
					will use the if-command. This command has the following syntax:
				</p>
				
				<p>
					if [ CONDITION_TO_EVALUATE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF THE CONDITION IS TRUE&gt;<br>
					elif [ OTHER_CONDITION_TO_EVALUATE_IF_1ST_CONDITION_IS_FALSE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF FIRST CONDITION IS FALSE BUT SECOND IS TRUE&gt;<br>
					else<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF ALL THE PREVIOUS CONDITIONS ARE FALSE&gt;<br>
					fi
				</p>
				
				<p>
					The CONDITION_TO_EVALUATE is an expression that follows a specific syntax depending on what you want to 
					test (checking files, string comparison, comparing numbers, or combining different expressions). Lets 
					look at the different syntaxes used in each of these situations and at some examples that will help you 
					understand this seemingly confusing subject.
				</p>
				
				<h3>6.1. Condition-testing to check files</h3>
					<p>
						In the following table, <font class="bashcommand">FILE</font> refers to the path of the file or to the 
						variable that contains the path of the file. The spaces after <font class="bashcommand">[</font> and 
						before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will 
						give an error.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -a FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -d FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a directory.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -e FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -f FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a regular file.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -g FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SGID bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -h FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -k FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its sticky bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -p FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a named pipe (FIFO).</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -r FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is readable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -s FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has a size greater than zero.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -t FD ]</font>
							</td>
							<td>Tests if file descriptor <font class="bashcommand">FD</font> is open and refers to a terminal.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -u FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SUID (set user ID) bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -w FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is writable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -x FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is executable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -O FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective user ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -G FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective group ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -L FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -N FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has been modified since it was last read.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -S FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a socket.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -nt FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> has been changed more recently than <font class="bashcommand">FILE2</font>, or if <font class="bashcommand">FILE1</font> exists and <font class="bashcommand">FILE2</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ot FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> is older than <font class="bashcommand">FILE2</font>, or is <font class="bashcommand">FILE2</font> exists and <font class="bashcommand">FILE1</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ef FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> and <font class="bashcommand">FILE2</font> refer to the same device and inode numbers.</td>
						</tr>
					</table>
					
				<p>
					In the following section you will not find examples of the following flags because they are related to user permissions, a topic that has not been explained yet and will be explained in future chapters, or because they are less common. However, the use of these flags is the same as the ones explained below. 
				</p>
				
				<p>
					<font class="example">[ -a FILE ]:</font>
					<font class="bashcommand">
						FILE=/Users/MyUser/Desktop/someFile.txt<br>
						if [ -a "${FILE}" ]<br>
						then<br>
						echo "${FILE} exists"<br>
						else<br>
						echo "${FILE} doesn't exist"<br>
						fi 
					</font>
				</p>
				
				<p>
					<font class="bashcommand">
						if [ -a "/Users/MyUser/Desktop/someFile.txt" ]<br>
						then<br>
						echo "The file exists"<br>
						else<br>
						echo "The file doesn''t exist"<br>
						fi 
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the quotation marks surrounding the file path are missing. Since the path has spaces, bash gives an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						if [ -a /Users/MyUser/Desktop/some file name with spaces.txt ]<br>
						then<br>
						echo "The file exists"<br>
						else<br>
						echo "The file doesn't exist"<br>
						fi<br>
						-bash: [: too many arguments 
					</font>
				</p>
				
				<p>
					<font class="example">[ -d FILE ]:</font>
					<font class="bashcommand">
						FILE=/Users/MyUser/Desktop/someFile.txt<br>
						if [ -a "${FILE}" ]<br>
						then<br>
						echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						if [ -d "${FILE}" ]<br>
						then<br>
						echo "It is a directory."<br>
						else<br>
						echo "It is a regular file."<br>
						fi<br>
						else<br>
						echo "The file doesn't exist."<br>
						fi
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the spaces before and after the expression (<font class="bashcommand">-a "${FILE}"</font>) are missing. So, bash will give an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						FILE=/Users/MyUser/Desktop/someFile.txt<br>
						if [-a "${FILE}"]<br>
						then<br>
						echo "The file exists. Now I will find out if it’s a directory or a regular file."<br>
						if [ -d "${FILE}" ]<br>
						then<br>
						echo "It is a directory."<br>
						else<br>
						echo "It is a regular file."<br>
						fi<br>
						else<br>
						echo "The file doesn’t exist."<br>
						Fi<br>
						-bash: [-a: command not found
					</font>
				</p>
				
				<p>
					<font class="example">[ -f FILE ]:</font>
					<font class="bashcommand">
						FILE=/Users/MyUser/Desktop/someFile.txt<br>
						if [ -a "${FILE}" ]<br>
						then<br>
						echo "The file exists. Now I will find out if it’s a directory or a regular file."<br>
						if [ -f "${FILE}" ]<br>
						then<br>
						echo "It is a regular file."<br>
						else<br>
						echo "It is a directory."<br>
						fi<br>
						else<br>
						echo "The file doesn’t exist."<br>
						fi
					</font>
				</p>
				
				<p>
					<font class="example">[ -N FILE ]:</font>
					<font class="bashcommand">
						if [ -N "/Users/MyUser/Desktop/someFile.txt" ]<br>
						then<br>
						echo "The file exists and has been modified since the last time it was opened."<br>
						else<br>
						echo "Either the file doesn’t exist, or it hasn’t been modified."<br>
						fi 
					</font>
				</p>
				
				<h3>6.2. Condition-testing to compare/evaluate strings</h3>
					<p>
						When comparing strings, it is mandatory to use the quotation marks. The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error. 
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -z "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -n "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is non-zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" == "STRING2" ]</font>
							</td>
							<td>Tests if the strings are equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" != "STRING2" ]</font>
							</td>
							<td>Tests if the strings are not equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \< "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts before <font class="bashcommand">STRING2</font></td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \> "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts after <font class="bashcommand">STRING2</font></td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ -z "STRING" ]:</font>
						<font class="bashcommand">
							if [ -z "" ]<br>
							then<br>
							echo "Empty string"<br>
							fi<br>
							Empty string 
						</font>
					</p>
					
					<p>
						<font class="example">[ -n "STRING" ]:</font>
						<font class="bashcommand">
							VAR="Some text"<br>
							if [ -n "${VAR}" ]<br>
							then<br>
							echo "The string is not empty"<br>
							fi<br>
							The string is not empty 
						</font>
					</p>
					
					<p>In this example, bash will show an error because I forgot to put the quotation marks around <font class="bashcommand">${VAR}</font>.</p>
					
					<p>
						<font class="bashcommand">
							VAR="Some text"<br>
							if [ -n ${VAR} ]<br>
							then<br>
							echo "The string is not empty"<br>
							fi<br>
							-bash: [: Some: binary operator expected 
						</bash>
					</p>
					
					<p>
						<font class="example">[ "STRING1" == "STRING2" ]:</font>
						<font class="bashcommand">
							QC="Good"<br>
							if [ "${QC}" == "Good" ]<br>
							then<br>
							echo "Quality control good"<br>
							else<br>
							echo "Image has bad quality"<br>
							fi<br>
							Quality control good 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" != "STRING2" ]:</font>
						<font class="bashcommand">
							QC="Good"<br>
							if [ "${QC}" != "Good" ]<br>
							then<br>
							echo "Quality control is not good"<br>
							else<br>
							echo "Image has good quality"<br>
							fi<br>
							Image has good quality
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" \< "STRING2" ]:</font>
						In the following example, I am comparing the strings <font class="bashcommand">"Canada"</font> with <font class="bashcommand">"Colombia"</font> and printing the one that sorts first. <font class="bashcommand">"Canada"</font> will be printed because the first letter of both words is the same but the second letter in <font class="bashcommand">"Canada"</font> (letter <font class="bashcommand">a</font>) comes before the second letter in <font class="bashcommand">"Colombia"</font> (letter <font class="bashcommand">o</font>).<br>
						<font class="bashcommand">
							VAR1="Canada"<br>
							VAR2="Colombia"<br>
							if [ "${VAR1}" \< "${VAR2}" ]<br>
							then<br>
							echo ${VAR1}<br>
							else<br>
							echo ${VAR2}<br>
							fi<br>
							Canada
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" \> "STRING2" ]:</font>
						<font class="bashcommand">
							VAR1="Canada"<br> 
							VAR2="Colombia"<br>
							if [ "${VAR1}" \> "${VAR2}" ]<br>
							then<br>
							echo ${VAR2}<br>
							else<br>
							echo ${VAR1}<br>
							fi<br>
							Canada 
						</font>
					</p>
					
				<h3>6.3. Condition-testing to compare numbers</h3>
					<p>Content of section 6.3</p>
					
				<h3>6.4. Condition-testing to compare arrays</h3>
					<p>Content of section 6.4</p>
		    </div>
		       
		    <div id="content7" class="hidden">
		    	<h2>7. Iteration</h2>
		    	
		    	<h3>7.1. The for loop</h3>
		    		<p>Content of section 7.1</p>
		    		
		    	<h3>7.2. From for to while</h3>
		    		<p>Content of section 7.2</p>
		    		
		    	<h3>7.3. The while loop</h3>
		    		<p>Content of section 7.3</p>
		    </div>
		       
		    <div id="content8" class="hidden">
		    	<h2>8. General file manipulation</h2>
		    	
		    	<h3>8.1. Basic concepts and simple commands</h3>
		    		<p>Content of section 8.1</p>
		    		
		    	<h3>8.2. Listing files using patterns</h3>
		    		<p>Content of section 8.2</p>
		    		
		    	<h3>8.3. Frequently used commands for file manipulation</h3>
		    		<p>Content of section 8.3</p>
		    		
		    	<h3>8.4. Writing files</h3>
		    		<p>Content of 8.4</p>
		    		
		    	<h3>8.5. Reading files</h3>
		    		<p>Content of 8.5</p>
		    </div>
		       
		    <div id="content9" class="hidden">
		    	<h2>9. Manipulating text and csv files</h2>
		    	
		    	<h3>9.1. The awk command</h3>
		    		<p>Content 9.1</p>
		    		
		    	<h3>9.2. The grep command</h3>
		    		<p>Content 9.2</p>
		    </div>
		       
		    <div id="content10" class="hidden">
		    	<h2>10. Manipulating image files</h2>
		    		<p>Content of section 10</p>
		    </div>
		       
		    <div id="content11" class="hidden">
		    	<h2>11. Writing more complex bash scripts</h2>
		    	
		    	<h3>11.1. Reading arguments</h3>
		    		<p>Content 11.1</p>
		    		
		    	<h3>11.2. Using functions</h3>
		    		<p>Content 11.2</p>
		    		
		    	<h3>11.3. Creating/importing libraries</h3>
		    		<p>Content 11.3</p>
		    		
		    	<h3>11.4. Scripting processes in parallel</h3>
		    		<p>Content 11.4</p>
		    </div>
		       
		    <div id="content12" class="hidden">
		    	<h2>12. Remote shell</h2>
		    		<p>Content of section 12</p>
		    </div>
		       
		    <div id="content13" class="hidden">
		    	<h2>13. Cluster jobs</h2>
		    		<p>Content of section 13</p>
		    </div>
		       
		    <div id="content14" class="hidden">
		    	<h2>14. Downloading files from the web using the command line</h2>
		    		<p>Content section 14</p>
		    </div>
		       
		    <div id="content15" class="hidden">
		    	<h2>15. Creating backups</h2>
		    		<p>Content section 15</p>
		    </div>
		       
		    <div id="content16" class="hidden">
		    	<h2>16. File permissions</h2>
		    		<p>Content of section 16</p>
		    </div>
		       
		    <div id="content17" class="hidden">
		    	<h2>17. Using aliases</h2>
		    		<p>Content of section 17</p>
		    </div>
		       
		    <div id="content18" class="hidden">
		    	<h2>18. keyboard shortcuts for MacOS</h2>
		    		<p>Content of section 18</p>
		    </div>
		  </article>
		</section>
		
		<footer>
			<p>
				Last update: April 29 / 2020<br>
				All the content from this tutorial was originally created by the author<br>
				Author: <a href="http://linkedin.com/in/monicakeithmri" target="_blank">Monica Keith</a>
			</p>
		</footer>
	</body>
</html>
